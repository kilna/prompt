#!/bin/bash

if [ ! "$BASH" ]; then
  echo "Script is only compatible with bash, current shell is $SHELL" >&2
  exit 1
fi

trap "$(shopt -p extglob)" RETURN
shopt -s extglob

title() {
  export PS1_TITLE="$1"
}

notitle() {
  unset PS1_TITLE
}

prompt() {
  export PS1="$PS1_ORIG"
  __ps1_debug "Running $PS1_SCRIPT"
  if [[ -e $PS1_SCRIPT ]]; then
    source $PS1_SCRIPT "$@"
  else
    echo "Unable to find PS1_SCRIPT: $PS1_SCRIPT" >&2
    return 1
  fi
}

noprompt() {
  export PS1="$PS1_ORIG"
  local debug="$PS1_DEBUG"
  for var in $(__ps1_vars); do
    [[ "$debug" ]] && echo "Unsetting $var" >&2
    unset $var &>/dev/null
  done
  for func in $(__ps1_funcs) title notitle prompt noprompt; do
    [[ "$debug" ]] && echo "Unsetting $func" >&2
    unset -f $func &>/dev/null
  done
}

__ps1_lookup() {
  if typset -F __ps1_$1; then
    __ps1_$1
    return $?
  fi
  if typset -F ps1_$1; then
    ps1_$1
    return $?
  fi
  if typeset $1; then
    eval 'echo -n $ps1_'"$1"
    return 0
  fi
  return 1
}

__ps1_funcs() {
  while IFS='' read line; do
    local f=($line)
    if [[ "${f[0]}" == 'declare' &&
          "${f[1]}" == '-f' && 
          "${f[2]}" == '__ps1_'*
       ]]; then
      echo -n "${f[2]} "
    fi
  done < <(typeset -F)
}

__ps1_vars() {
  while IFS='' read line; do
    local f=($line)
    if [[ "${f[0]}" == 'declare' &&
          "${f[1]}" == '-x' &&
          "${f[2]}" == 'PS1_'*'='
       ]]; then
      echo -n "${f[2]%%=*} "
    fi
  done < <(typeset -x)
}

__ps1_debug() { [[ "$PS1_DEBUG" ]] && echo "$@" >&2; }

__ps1_unicode() {
  case "$LANG" in
    *'UTF-8'*) return 0;;
    *)         return 1;;
  esac
}

__ps1_powerline() {
  __ps1_unicode || return 1
  if [[ "${PS1_POWERLINE:-0}" != 1 ]]; then return 1; fi
  return 0
}

__ps1_load_style() {
  local file="$1"
  local is_unicode=0
  local code=''
  while IFS='' read line; do
    [[ "$line" == '#'* || "$line" =~ ^[[:space:]]*$ ]] && continue
    if [[ "$line" != *':'* ]]; then
      echo "Unable to parse line '$line' in file '$file'" >&2
      continue
    else
      name="${line%%=*}"
      name="${name## }"
      name="${name%% }"
      val="${line#*=}"
      val="${val## }"
      val="${val%% }"
      [[ "$val" == *'{u:'* ]] && is_unicode=1
      code+="export PS1_STYLE_${name^^}='${val//\'/\\\'}'"$'\n';
    fi
  done < "$file"
  if [[ ! __ps1_unicode && is_unicode ]]; then
    echo "File '$file' contains unicode style information but terminal is not UTF-8" >&2
  fi
  eval "$code"
}

__ps1_parse_tags() {
  local ar=()
  for str in "$@"; do
    while [[ "$str" != '' ]]; do
      x="${str%%\{*}"
      [[ "$x" = "$str" ]] || idx1=$(( ${#x} + 1 ))
      x="${str%%\}*}"
      [[ "$x" = "$str" ]] || idx2=$(( ${#x} + 1 ))
      nontag_val=''
      tag_val=''
      if [[ "$idx1" != '' && "$idx2" != '' && (( idx2 > idx1 )) ]]; then
        substr="${str:0:$idx2}"
        x="${substr%\{*}"
        [[ "$x" = "$substr" ]] || idx1=$(( ${#x} + 1 ))
        if [[ "$idx1" == '' ]]; then
          nontag_val+="$substr"
        else
          idx1x=$(( idx1 - 1 ))
          if (( idx1 != 0 )); then
            nontag_val+="${str:0:$idx1x}"
          fi
          idx2x=$(( idx2 - idx1 + 1 ))
          tag_val="${str:$idx1x:$idx2x}"
        fi
        str="${str:$idx2}"
      else
        nontag_val+="$str"
        str=''
      fi
      ar_idx=$(( ${#ar[@]} - 1 ))
      if [[ "$nontag_val" != '' ]]; then
        if [[ "$ar_idx" -lt 0 || "${ar[$ar_idx]}" == '{'*'}' ]]; then
          ar+=("$nontag_val")
        else
          ar[$ar_idx]+="$nontag_val" 
        fi
      fi
      if [[ "$tag_val" != '' ]]; then
        ar+=("$tag_val")
      fi
    done
  done
  export ps1_tags_parsed=''
  for chunk in "${ar[@]}"; do
    ps1_tags_parsed+="$chunk"$'\033'
  done
}

__ps1_ansi_echo() {
  [[ -z "$PS1_COLORS" || "$PS1_COLORS" == '0' ]] || echo -en "$1"
}

__ps1_ansi_style() {
  [[ "$PS1_BOLD" ]] && __ps1_ansi '{bold}'
  for property in "$1" 'default'; do
    for style in ${PS1_STYLES}; do
      local out
      IFS='' read -r out < <(__ps1_style_${style}_${property} 2>/dev/null)
      if [[ "$out" != '' ]]; then
        __ps1_ansi "$out"
        return
      fi
    done
  done
}

__ps1_rgb() {
  # Rounds to the nearest ANSI 216 color cube or 24 grayscale value. See:
  # https://docs.google.com/spreadsheets/d/1n4zg5OXYC0hBdRKBb1clx4t2HSx_cu_iiot6GYpgh1c/
  local ansi_fgbg="$1" # ANSI fg/bg code (either 3 or 4)
  local r="$2"
  local g="$3"
  local b="$4"

  # If we're in 24 bit mode we don't have to round, return using RGB syntax
  if [[ "$PS1_COLORS" == '24bit' ]]; then
    echo -n '\e['"${ansi_fgbg}8;2;${r};${g};${b}m"
    return
  fi

  local min=''
  local max=''
  local total=0
  for c in $r $g $b; do
    if [[ "$min" == '' ]] || (( c < min )); then min="$c"; fi
    if [[ "$max" == '' ]] || (( c > max )); then max="$c"; fi
    total=$(( total + c ))
  done

  local idx=''
  if (( ( max - min ) <= 26 )); then
    # If the delta between min and max is less than 26 (roughly 1/2 the 51.2
    # shades per 6x6x6 colors) then the color is effectively gray.
    local gray=$(( total / 3 )) # RGB colors as passed averaged into single 0-255 gray
    if ((
      ( gray >= 8   && gray < 51  ) || ( gray >= 58  && gray < 102 ) ||
      ( gray >= 108 && gray < 153 ) || ( gray >= 158 && gray < 204 ) ||
      ( gray >= 208 && gray < 248 )
    )); then
      # If we aren't better matched to the 6x6x6 cube, use a 24-shade ANSI gray
      idx=$(( 230 + ( ( $gray + 12 ) / 10 ) ))
    fi
  fi

  if [[ "$idx" == '' ]]; then
    # Otherwise, map to ANSI 216 indexed color cube
    idx=$((
      16 + ( ( ( $r + 26 ) / 51 ) * 36 ) + ( ( ( $g + 26 ) / 51 ) * 6  )
         + ( ( ( $b + 26 ) / 51 ) * 1  )
    ))
  fi

  echo -n '\e['"${ansi_fgbg}8;5;${idx}m"
}

__ps1_color() {
  # If we're foreground $g is set to 3, if background it's set to 4
  local ansi_fgbg='3'; if [[ "${1:0:2}" == 'bg' ]]; then ansi_fgbg='4'; fi
  local spec="${1:3}"
  __ps1_debug "COLOR TAG: $1 FG/BG: $g SPEC: $spec"
  case "$spec" in
    black)    echo -n '\e['"${ansi_fgbg}0m";;
    red)      echo -n '\e['"${ansi_fgbg}1m";;
    green)    echo -n '\e['"${ansi_fgbg}2m";;
    yellow)   echo -n '\e['"${ansi_fgbg}3m";;
    blue)     echo -n '\e['"${ansi_fgbg}4m";;
    magenta)  echo -n '\e['"${ansi_fgbg}5m";;
    cyan)     echo -n '\e['"${ansi_fgbg}6m";;
    white)    echo -n '\e['"${ansi_fgbg}7m";;
    +([0-9])) echo -n '\e['"${ansi_fgbg}8;5;${spec}m";;
    +([0-9]),+([0-9]),+([0-9]))
              __ps1_rgb "$ansi_fgbg" ${spec//,/ };;
    '#'[0-9A-Fa-f][0-9A-Fa-f][0-9A-Fa-f][0-9A-Fa-f][0-9A-Fa-f][0-9A-Fa-f])
              __ps1_rgb \
                "$ansi_fgbg" \
                "$(( 16#${spec:1:2} ))" \
                "$(( 16#${spec:3:2} ))" \
                "$(( 16#${spec:5:2} ))"
              ;;
    '#'[0-9A-Fa-f][0-9A-Fa-f][0-9A-Fa-f])
              __ps1_rgb \
                "$ansi_fgbg" \
                "$(( ( 16#${spec:1:1} * 16 ) + 16#${spec:1:1} ))" \
                "$(( ( 16#${spec:2:1} * 16 ) + 16#${spec:2:1} ))" \
                "$(( ( 16#${spec:3:1} * 16 ) + 16#${spec:3:1} ))"
              ;;
  esac
}

__ps1_ansi() {
  __ps1_parse_tags "$@"
  local chunks=()
  while IFS='' read -r -d $'\033' chunk; do
    __ps1_debug "CHUNK: '$chunk'"
    chunks+=("$chunk")
  done < <(echo "${ps1_tags_parsed}")
  set -- "${chunks[@]}"
  unset chunks ps1_tags_parsed
  trap "$(shopt -p extglob)" RETURN
  shopt -s extglob
  while (( $# > 0 )); do
    arg="$1"
    shift
    [[ "$arg" != '{'*'}' ]] && echo -n "$arg" && continue
    tag="${arg:1:$(( ${#arg} - 2 ))}"
    case "$tag" in
      style:*)    __ps1_ansi_style "${tag:6}";;
      /style:*)   __ps1_ansi_style "${tag:7}_end";;
      eol)        __ps1_ansi_echo '\n\e[0m';; # Handy when bash eats a trailing newline
      clear)      __ps1_ansi_echo '\e[H\e[2J';;
      reset)      __ps1_ansi_echo '\e[0m';;
      fg:*|bg:*)  IFS='' read -d $'\0' -r color < <(__ps1_color $tag);
                  __ps1_debug "COLOR: $color";
                  __ps1_ansi_echo "$color";;
      bold)       __ps1_ansi_echo '\e[1m';;
      /bold)      __ps1_ansi_echo '\e[21m';;
      dim)        __ps1_ansi_echo '\e[2m';;
      /dim)       __ps1_ansi_echo '\e[22m';;
      italic)     __ps1_ansi_echo '\e[3m';;
      /italic)    __ps1_ansi_echo '\e[23m';;
      underline)  __ps1_ansi_echo '\e[4m';;
      /underline) __ps1_ansi_echo '\e[24m';;
      blink)      __ps1_ansi_echo '\e[5m';;
      /blink)     __ps1_ansi_echo '\e[25m';;
      fastblink)  __ps1_ansi_echo '\e[6m';;
      /fastblink) __ps1_ansi_echo '\e[26m';;
      reverse)    __ps1_ansi_echo '\e[7m';;
      /reverse)   __ps1_ansi_echo '\e[27m';;
      hidden)     __ps1_ansi_echo '\e[8m';;
      /hidden)    __ps1_ansi_echo '\e[28m';;
      space)      echo -n ' ';;
      *)          echo -n "{$tag}";;
    esac
  done
}

__ps1_title() {
  local last_err="$?" # Cache last command's error...
  if [[ "$PS1_TITLE" ]]; then
    case "$PS1_TITLE_MODE" in
      prepend)     echo -n "$PS1_TITLE"' - ';;
      append)      echo -n ' - '"$PS1_TITLE";;
      interpolate) echo -n "$PS1_TITLE";;
    esac
  fi
  return $last_err # Needed by __ps1_modules to show error
}

__ps1_prompt_title() {
  if [[ "$PS1_TITLE_MODE" != 'disabled' ]]; then
    echo -n '\[\e]0;\]'
    case "$PS1_TITLE_MODE" in
      static)      echo -n "$PS1_TITLE_FORMAT";;
      prepend)     echo -n '`__ps1_title`'"$PS1_TITLE_FORMAT";;
      append)      echo -n "$PS1_TITLE_FORMAT"'`__ps1_title`';;
      interpolate) echo -n "${PS1_TITLE_FORMAT//\\z/'`__ps1_title`'}";;
    esac
    echo -n '\a'
  fi
}

__ps1_prompt_style() {
  [[ "$PS1_BOLD" ]] && __ps1_prompt '{bold}'
  for property in $1 default; do
    for style in ${PS1_STYLES}; do
      local out
      IFS='' read -r out < <(__ps1_style_${style}_${property} 2>/dev/null)
      if [[ "$out" != '' ]]; then
        __ps1_prompt "$out"
        return
      fi
    done
  done
}

__ps1_prompt() {
  __ps1_parse_tags "$@"
  local chunks=()
  while IFS='' read -r -d $'\033' chunk; do
    __ps1_debug "CHUNK: '$chunk'"
    chunks+=("$chunk")
  done < <(echo "${ps1_tags_parsed}")
  set -- "${chunks[@]}"
  trap "$(shopt -p extglob)" RETURN
  shopt -s extglob
  while (( $# > 0 )); do
    arg="$1"
    shift
    [[ "$arg" != '{'*'}' ]] && echo -n "$arg" && continue
    tag="${arg:1:$(( ${#arg} - 2 ))}"
    case "$tag" in
      style:*)     __ps1_prompt_style "${tag:6}";;
      /style:*)    __ps1_prompt_style "${tag:7}_end";;
      eol)         echo -n '\n\[\e[0m\]';; # Handy when bash eats a trailing newline
      clear)       echo -n '\[\e[H\e[2J\]';;
      reset)       echo -n '\[\e[0m\]';;
      fg:*|bg:*)   echo -n '\['; __ps1_color "$tag"; echo -n '\]';;
      bold)        echo -n '\[\e[1m\]';;
      /bold)       echo -n '\[\e[21m\]';;
      dim)         echo -n '\[\e[2m\]';;
      /dim)        echo -n '\[\e[22m\]';;
      italic)      echo -n '\[\e[3m\]';;
      /italic)     echo -n '\[\e[23m\]';;
      underline)   echo -n '\[\e[4m\]';;
      /underline)  echo -n '\[\e[24m\]';;
      blink)       echo -n '\[\e[5m\]';;
      /blink)      echo -n '\[\e[25m\]';;
      fastblink)   echo -n '\[\e[6m\]';;
      /fastblink)  echo -n '\[\e[26m\]';;
      reverse)     echo -n '\[\e[7m\]';;
      /reverse)    echo -n '\[\e[27m\]';;
      hidden)      echo -n '\[\e[8m\]';;
      /hidden)     echo -n '\[\e[28m\]';;
      user)        __ps1_prompt '{style:user}\u{/style:user}';;
      dir)         __ps1_prompt '{style:dir}\w{/style:dir}';;
      basename)    __ps1_prompt '{style:basename}\W{/style:basename}';;
      host)        __ps1_prompt '{style:host}\h{/style:host}';;
      fqdn)        __ps1_prompt '{style:fqdn}\H{/style:fqdn}';;
      prompt)      __ps1_prompt '{style:prompt}\${/style:prompt}';;
      date)        __ps1_prompt '{style:date}\d{/style:date}';;
      time)        __ps1_prompt '{style:time}\t{/style:time}';;
      time12)      __ps1_prompt '{style:time12}\T{/style:time12}';;
      ampm)        __ps1_prompt '{style:ampm}\@{/style:ampm}';;
      module:*)    echo -n '`__ps1_module '${tag:8}'`';;
      modules)     echo -n '`__ps1_modules`';;
      modules:eol) echo -n '`__ps1_modules -n`';;
      modules:pad) echo -n '`__ps1_modules -p`';;
      *)           echo -n "{$tag}";;
    esac
  done
}

__ps1_module() {
  local exit="$?"
  module="$1"
  __ps1_debug "module: $module"
  #local out="$(__ps1_module_${module} 2>/dev/null)"
  local out
  IFS='' read -r out < <(__ps1_module_${module} 2>/dev/null)
  __ps1_debug "   out: $out"
  [[ "$out" ]] || return $exit
  __ps1_ansi_style $module
  __ps1_ansi_style module
  echo -n "$out"
  __ps1_ansi_style module_end
  __ps1_ansi_style ${module}_end
  return $exit
}

__ps1_modules() {
  PS1_LAST_ERR="$?"
  local newline=0
  if [[ "$1" == '-n' ]]; then
    newline=1
    shift
  fi
  local pad=0
  if [[ "$1" == '-p' ]]; then
    pad=1
    shift
  fi
  local enabled_modules=0
  for module in ${PS1_MODULES}; do
    #local module_out="$(__ps1_module $module)"
    local module_out
    IFS='' read -r module_out < <(__ps1_module $module)
    [[ "$module_out" ]] || continue
    (( enabled_modules++ )) && __ps1_ansi_style 'module_pad'
    echo -n "$module_out"
    __ps1_ansi '{reset}'
  done
  if [[ "$enabled_modules" > 0 ]]; then
    if [[ "$newline" == 1 ]]; then
      __ps1_ansi '{eol}'
    elif [[ "$pad"     == 1 ]]; then
      __ps1_ansi_style 'module_pad'
    fi
  fi
  local err="$PS1_LAST_ERR"
  unset PS1_LAST_ERR
  return $err
}

__ps1_get_colors() {
  case "$TERM$COLORTERM" in
    *truecolor*|*24bit*) echo '24bit'; return;;
    *256*)               echo '256';   return;;
  esac
  trap "$(shopt -p extglob)" RETURN
  shopt -s extglob
  local t
  IFS='' read -r t < <(infocmp 2>/dev/null)
  if [[ "$t" == *+([[:space:]])@(set24f|setf24|setrgbf)=* ]]; then
    echo '24bit'
    return
  fi
  local REPLY
  echo -e -n '\e]4;1;?\a'
  read -p "$(echo -e -n '\e]4;1;?\a')" -d $'\a' -s -t 0.1 </dev/tty
  if ! [[ -z "$REPLY" ]]; then
    local colors=''
    for idx in 255 15 7; do
      printf '\e]4;%d;?\a' $idx
      read -d $'\a' -s -t 0.1 </dev/tty
      if ! [[ -z "$REPLY" ]]; then
        echo $(( idx + 1 ))
        return
      fi
    done
  fi
  IFS='' read -r t < <(tput colors 2>/dev/null)
  (( t == 8 || t == 16 || t == 256 )) && echo "$t"
}

for var in $(__ps1_vars); do
  [[ "$var" != 'PS1_ORIG' ]] && unset $var
done

# Process --key=val args into --key val, un-bundle single-letter flags,
# and treat -- as the end of explicit options
ar=()
for (( i=1; i<=$#; i++ )); do
  a="${@:$i:1}"
  [[   "$a" == '--'       ]] && ar+=("${@:$i}")            && break
  [[   "$a" == '--'*'='*  ]] && ar+=("${a%%=*}" "${a#*=}") && continue
  [[ ! "$a" =~ ^-([^-]+)$ ]] && ar+=("$a")                 && continue
  for (( x=1; x<${#a}; x++ )); do ar+=("-${a:$x:1}"); done
done
set -- "${ar[@]}"
unset a ar


PS1_STYLES='user default'
PS1_ROOT="$(cd `dirname ${BASH_SOURCE[0]}` &>/dev/null; echo $PWD)"
PS1_NAME="${BASH_SOURCE[0]##*/}"
PS1_SCRIPT="$PS1_ROOT/$PS1_NAME"
IFS='' read -r PS1_COLORS < <(__ps1_get_colors)

user_styles=()
load_modules=()
while (( $# > 0 )); do
  arg="$1"
  shift
  case "$arg" in
    -m|--module)       load_modules+=("$1"); shift ;;
    -a|--all-modules)  all_modules=1 ;;
    -b|--bold)         PS1_BOLD=1 ;;
    -s|--style)        PS1_STYLES="$1 ${PS1_STYLES}"; shift ;;
    -u|--user-style)   user_styles+=("$1"); shift ;;
    -p|--prompt)       set_prompt="$1"; shift ;;
    -l|--powerline)    PS1_POWERLINE=1 ;;
    -d|--debug)        PS1_DEBUG=1 ;;
    -c|--colors)       PS1_COLORS=("$1"); shift ;;
    -f|--title-format) PS1_TITLE_FORMAT="$1"; shift ;;
    -t|--title-mode)   PS1_TITLE_MODE="$1"; shift ;;
    -h|--help)         show_help=1 ;;
  esac
done

if [[ "$show_help" ]]; then
  for p in $PAGER less more cat; do
    which $p &>/dev/null && pager="$p" && break
  done
  cat <<EOF | $pager
USAGE: source $PS1_NAME [options]

Sets the prompt in a bash session

Options:

          --prompt VAL :  The desired custom prompt using style formatting
                -p VAL    Defaults to modules on their own line, followed by
                          user@host directory on its own line, followed by
                          a prompt ($ for user or # for root)

         --module NAME :  Enable module NAME
               -m NAME    Modules can be found in:
                            $PS1_ROOT/module

         --all-modules :  Enable all modules
                    -a

          --style NAME :  Enable style NAME
               -s NAME    Styles can be found in:
                            $PS1_ROOT/style

         --colors SPEC :  Override auto-detection for the number of ANSI colors
               -c SPEC      the current terminal supports.

                          SPEC is one of:
                            0       No ANSI color support
                            8
                            16
                            256
                            24bit   Truecolor ANSI terminal support

           --powerline :  Use Powerline font symbols
                    -l

                --bold :  Bold all styles
                    -b

                --help :  Shows help
                    -h

               --debug :  Enable debugging information
                    -d

 --title-format FORMAT :  Format for status line / window title using bash
             -f FORMAT    PS1 syntax

     --title-mode MODE :  Sets how status line / window title is handled
               -t MODE    Custom titles can be set with the 'title' command

                          MODE is one of:
                            prepend      Add custom-set title as the
                                         begining (default)

                            append       Add custom-set title at the end

                            static       No custom-set title

                            interpolate  Interpolate escape \\z in
                                         title-format as custom set title

                            disabled     No title set in prompt

For more information and additonal usage: https://github.com/kilna/prompt

EOF
  unset pager show_help
  [[ "${BASH_SOURCE[0]}" == "$0" ]] && exit 0 || return 0
fi
unset show_help

if [[ "${BASH_SOURCE[0]}" == "$0" ]]; then
  cat <<EOF >&2
This script is meant to be added into a Bash shell session via:

source $PS1_NAME

After loading, you can use 'prompt' to reload.
EOF
  exit 1
fi

__ps1_debug "PS1_ROOT: $PS1_ROOT"
__ps1_debug "PS1_NAME: $PS1_NAME"
__ps1_debug "PS1_SCRIPT: $PS1_SCRIPT"

if [[ "$all_modules" ]]; then
  load_modules=()
  for module_path in $PS1_ROOT/module/*; do
    load_modules+=("${module_path##*/}")
  done
fi
unset all_modules

for func in $(__ps1_funcs); do
  if [[ "$func" == '__ps1_module_'* || "$func" == '__ps1_style_'* ]]; then
    __ps1_debug "Unsetting $func"
    unset -f $func
  fi
done

for user_style in "${user_styles[@]}"; do
  str="__ps1_style_user_${user_style%%=*}() { echo -n '${user_style#*=}'; }"
  __ps1_debug "$str"
  eval "$str"
done
unset user_styles

err=0

PS1_MODULES=''
for module in "${load_modules[@]}"; do
  __ps1_debug "Loading module: $module"
  if ! source "${PS1_ROOT}/module/${module}"; then
    echo "Unable to open $PS1_NAME module $PS1_ROOT/modules/$module" >&2
    (( err++ ))
  fi
  if typeset -F __ps1_module_$module &>/dev/null; then
    __ps1_debug "Module $module loaded successfully"
    PS1_MODULES+="$module "
  fi
done

for style in ${PS1_STYLES}; do
  [[ "$style" == 'user' ]] && continue
  __ps1_debug "PS1_STYLE: $style"
  if ! source "${PS1_ROOT}/style/${style}"; then
    echo "Unable to open $PS1_NAME style $PS1_ROOT/style/$style" >&2
    (( err++ ))
  fi
done

PS1_TITLE_MODE="${PS1_TITLE_MODE:-prepend}"
__ps1_debug "PS1_TITLE_MODE: $PS1_TITLE_MODE"

PS1_TITLE_FORMAT="${PS1_TITLE_FORMAT:-\\u@\\h \\w}"
__ps1_debug "PS1_TITLE_FORMAT: $PS1_TITLE_FORMAT"

if [[ "${#set_prompt[@]}" -eq 0 ]]; then
  set_prompt='{modules:eol}{user}{reset}@{host} {dir}{eol}{prompt} {reset}'
fi

if [[ "$PS1_ORIG" == '' ]]; then PS1_ORIG="$PS1"; fi
__ps1_debug "PS1_ORIG: $PS1_ORIG"
__ps1_debug "Set prompt: $set_prompt"

IFS='' read -r -d $'\0' title < <(__ps1_prompt_title)
__ps1_debug "title: $title"
IFS='' read -r -d $'\0' prompt < <(__ps1_prompt "$set_prompt")
__ps1_debug "prompt: $prompt"
export PS1="$title$prompt"
(( err+="$?" ))
__ps1_debug "PS1: $PS1"
unset set_prompt

for func in $(__ps1_funcs); do
  if [[ "$func" == '__ps1_prompt_'* ]]; then
    [[ "$debug" ]] && echo "Unsetting $func" >&2
    unset -f $func &>/dev/null
  fi
done

return $err

