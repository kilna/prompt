#!/bin/bash

if [ ! "$BASH" ]; then
  echo "Script is only compatible with bash, current shell is $SHELL" >&2
  exit 1
fi

title() {
  export PS1_TITLE="$1"
}

notitle() {
  unset PS1_TITLE
}

prompt() {
  export PS1="$PS1_ORIG"
  __ps1_debug "Running $PS1_SCRIPT"
  if [[ -e $PS1_SCRIPT ]]; then
    source $PS1_SCRIPT "$@"
  else
    echo "Unable to find PS1_SCRIPT: $PS1_SCRIPT" >&2
    return 1
  fi
}

noprompt() {
  export PS1="$PS1_ORIG"
  local debug="$PS1_DEBUG"
  for var in $(typeset | grep -E ^PS1_.*= | cut -d '=' -f 1); do
    [[ "$debug" ]] && echo "Unsetting $var" >&2
    unset $var &>/dev/null
  done
  for func in $(typeset -F | cut -d ' ' -f 3 | grep -E '^__ps1_') title notitle prompt noprompt; do
    [[ "$debug" ]] && echo "Unsetting $func" >&2
    unset -f $func &>/dev/null
  done
}

__ps1_lookup() {
  if typset -F __ps1_$1; then __ps1_$1; return $?; fi
  if typset -F ps1_$1; then ps1_$1; return $?; fi
  if typeset $1; then eval 'echo -n $ps1_'"$1"; return 0; fi
  return 1
}

__ps1_debug() {
  [[ "$PS1_DEBUG" ]] && echo "$@" >&2
}

__ps1_unicode() {
  case "$LANG" in
    *'UTF-8'*) return 0;;
    *)         return 1;;
  esac
}

__ps1_parse_tags() {
  ar=()
  for str in "$@"; do
    while [[ "$str" != '' ]]; do
      x="${str%%\{*}"
      [[ "$x" = "$str" ]] || (( idx1 = ${#x} + 1 ))
      x="${str%%\}*}"
      [[ "$x" = "$str" ]] || (( idx2 = ${#x} + 1 ))
      nontag_val=''
      tag_val=''
      if [[ "$idx1" != '' && "$idx2" != '' && (( idx2 > idx1 )) ]]; then
        substr="${str:0:(( idx2 ))}"
        x="${substr%\{*}"
        [[ "$x" = "$substr" ]] || (( idx1 = ${#x} + 1 ))
        if [[ "$idx1" == '' ]]; then
          nontag_val+="$substr"
        else
          if (( idx1 != 0 )); then
            nontag_val+="${str:0:(( idx1 - 1 ))}"
          fi
          tag_val="${str:(( idx1 - 1 )):(( idx2 - idx1 + 1 ))}"
        fi
        str="${str:$idx2}"
      else
        nontag_val+="$str"
        str=''
      fi
      ar_idx=$(( "${#ar[@]}" - 1 ))
      if [[ "$nontag_val" != '' ]]; then
        if [[ "$ar_idx" -lt 0 || "${ar[$ar_idx]}" == '{'*'}' ]]; then
          ar+=("$nontag_val")
        else
          ar[$ar_idx]+="$nontag_val" 
        fi
      fi
      if [[ "$tag_val" != '' ]]; then
        ar+=("$tag_val")
      fi
    done
  done
  export ps1_tags_parsed=("${ar[@]}")
}

__ps1_ansi_echo() {
  case "$TERM" in
    linux|xterm*|*vt*|con*|*ansi*|screen) echo -en "$1";;
  esac
}

__ps1_ansi_style() {
  [[ "$PS1_BOLD" ]] && __ps1_ansi '{bold}'
  for property in "$1" 'default'; do
    __ps1_debug "PROPERTY: '$property'"
    for style in "${PS1_STYLES[@]}"; do
      __ps1_debug "  STYLE: '$style'"
      local out="$(__ps1_style_${style}_${property} 2>/dev/null)"
      if (( $? == 0 )); then
        __ps1_debug " RETURN: '$out'"
        __ps1_ansi "$out"
        return
      fi
      __ps1_debug "    OUT: '$out'"
    done
  done
}

__ps1_ansi() {
  export ps1_tags_parsed=()
  __ps1_parse_tags "$@"
  set -- "${ps1_tags_parsed[@]}"
  for x in "$@"; do __ps1_debug "CHUNK: '$x'"; done
  unset ps1_tags_parsed
  while (( "$#" > 0 )); do
    arg="$1"
    shift
    [[ "$arg" != '{'*'}' ]] && echo -n "$arg" && continue
    tag="${arg:1:$(( ${#arg} - 2 ))}"
    case "$tag" in
      style:*)    __ps1_ansi_style "${tag:6}";;
      /style:*)   __ps1_ansi_style "${tag:7}_end";;
      eol)        __ps1_ansi_echo '\n\e[0m';; # Handy when bash eats a trailing newline
      clear)      __ps1_ansi_echo '\e[H\e[2J';;
      reset)      __ps1_ansi_echo '\e[0m';;
      fg:black)   __ps1_ansi_echo '\e[30m';;
      fg:red)     __ps1_ansi_echo '\e[31m';;
      fg:green)   __ps1_ansi_echo '\e[32m';;
      fg:yellow)  __ps1_ansi_echo '\e[33m';;
      fg:blue)    __ps1_ansi_echo '\e[34m';;
      fg:magenta) __ps1_ansi_echo '\e[35m';;
      fg:cyan)    __ps1_ansi_echo '\e[36m';;
      fg:white)   __ps1_ansi_echo '\e[37m';;
      bg:black)   __ps1_ansi_echo '\e[30m';;
      bg:red)     __ps1_ansi_echo '\e[31m';;
      bg:green)   __ps1_ansi_echo '\e[32m';;
      bg:yellow)  __ps1_ansi_echo '\e[33m';;
      bg:blue)    __ps1_ansi_echo '\e[34m';;
      bg:magenta) __ps1_ansi_echo '\e[35m';;
      bg:cyan)    __ps1_ansi_echo '\e[36m';;
      bg:white)   __ps1_ansi_echo '\e[37m';;
      bold)       __ps1_ansi_echo '\e[1m';;
      dim)        __ps1_ansi_echo '\e[2m';;
      italic)     __ps1_ansi_echo '\e[3m';;
      underline)  __ps1_ansi_echo '\e[4m';;
      blink)      __ps1_ansi_echo '\e[5m';;
      fastblink)  __ps1_ansi_echo '\e[6m';;
      reverse)    __ps1_ansi_echo '\e[7m';;
      hidden)     __ps1_ansi_echo '\e[8m';;
      /bold)      __ps1_ansi_echo '\e[21m';;
      /dim)       __ps1_ansi_echo '\e[22m';;
      /italic)    __ps1_ansi_echo '\e[23m';;
      /underline) __ps1_ansi_echo '\e[24m';;
      /blink)     __ps1_ansi_echo '\e[25m';;
      /fastblink) __ps1_ansi_echo '\e[26m';;
      /reverse)   __ps1_ansi_echo '\e[27m';;
      /hidden)    __ps1_ansi_echo '\e[28m';;
      *)          echo -n "{$tag}";;
    esac
  done
}

__ps1_title() {
  local last_err="$?" # Cache last command's error...
  if [[ "$PS1_TITLE" ]]; then
    case "$PS1_TITLE_MODE" in
      prepend)     echo -n "$PS1_TITLE"' - ';;
      append)      echo -n ' - '"$PS1_TITLE";;
      interpolate) echo -n "$PS1_TITLE";;
    esac
  fi
  return $last_err # Needed by __ps1_modules to show error
}

__ps1_prompt_title() {
  if [[ "$PS1_TITLE_MODE" != 'disabled' ]]; then
    echo -n '\[\e]0;\]'
    case "$PS1_TITLE_MODE" in
      static)      echo -n "$PS1_TITLE_FORMAT";;
      prepend)     echo -n '`__ps1_title`'"$PS1_TITLE_FORMAT";;
      append)      echo -n "$PS1_TITLE_FORMAT"'`__ps1_title`';;
      interpolate) echo -n "${PS1_TITLE_FORMAT//\\z/'`__ps1_title`'}";;
    esac
    echo -n '\a'
  fi
}

__ps1_prompt_style() {
  [[ "$PS1_BOLD" ]] && __ps1_prompt '{bold}';
  for property in "$1" 'default'; do
    for style in "${PS1_STYLES[@]}"; do
      local out="$(__ps1_style_${style}_${property} 2>/dev/null)"
      if (( $? == 0 )); then
        __ps1_prompt "$out"
        return
      fi
    done
  done
}

__ps1_prompt() {
  export ps1_tags_parsed=()
  __ps1_parse_tags "$@"
  set -- "${ps1_tags_parsed[@]}"
  unset ps1_tags_parsed
  while (( "$#" > 0 )); do
    arg="$1"
    shift
    [[ "$arg" != '{'*'}' ]] && echo -n "$arg" && continue
    tag="${arg:1:$(( ${#arg} - 2 ))}"
    case "$tag" in
      style:*)     __ps1_prompt_style "${tag:6}";;
      /style:*)    __ps1_prompt_style "${tag:7}_end";;
      eol)         echo -n '\n\[\e[0m\]';; # Handy when bash eats a trailing newline
      clear)       echo -n '\[\e[H\e[2J\]';;
      reset)       echo -n '\[\e[0m\]';;
      fg:black)    echo -n '\[\e[30m\]';;
      fg:red)      echo -n '\[\e[31m\]';;
      fg:green)    echo -n '\[\e[32m\]';;
      fg:yellow)   echo -n '\[\e[33m\]';;
      fg:blue)     echo -n '\[\e[34m\]';;
      fg:magenta)  echo -n '\[\e[35m\]';;
      fg:cyan)     echo -n '\[\e[36m\]';;
      fg:white)    echo -n '\[\e[37m\]';;
      bg:black)    echo -n '\[\e[30m\]';;
      bg:red)      echo -n '\[\e[31m\]';;
      bg:green)    echo -n '\[\e[32m\]';;
      bg:yellow)   echo -n '\[\e[33m\]';;
      bg:blue)     echo -n '\[\e[34m\]';;
      bg:magenta)  echo -n '\[\e[35m\]';;
      bg:cyan)     echo -n '\[\e[36m\]';;
      bg:white)    echo -n '\[\e[37m\]';;
      bold)        echo -n '\[\e[1m\]';;
      dim)         echo -n '\[\e[2m\]';;
      italic)      echo -n '\[\e[3m\]';;
      underline)   echo -n '\[\e[4m\]';;
      blink)       echo -n '\[\e[5m\]';;
      fastblink)   echo -n '\[\e[6m\]';;
      reverse)     echo -n '\[\e[7m\]';;
      hidden)      echo -n '\[\e[8m\]';;
      /bold)       echo -n '\[\e[21m\]';;
      /dim)        echo -n '\[\e[22m\]';;
      /italic)     echo -n '\[\e[23m\]';;
      /underline)  echo -n '\[\e[24m\]';;
      /blink)      echo -n '\[\e[25m\]';;
      /fastblink)  echo -n '\[\e[26m\]';;
      /reverse)    echo -n '\[\e[27m\]';;
      /hidden)     echo -n '\[\e[28m\]';;
      user)        __ps1_prompt '{style:user}\u{/style:user}';;
      dir)         __ps1_prompt '{style:dir}\w{/style:dir}';;
      basename)    __ps1_prompt '{style:basename}\W{/style:basename}';;
      host)        __ps1_prompt '{style:host}\h{/style:host}';;
      fqdn)        __ps1_prompt '{style:fqdn}\H{/style:fqdn}';;
      prompt)      __ps1_prompt '{style:prompt}\${/style:prompt}';;
      date)        __ps1_prompt '{style:date}\d{/style:date}';;
      time)        __ps1_prompt '{style:time}\t{/style:time}';;
      time12)      __ps1_prompt '{style:time12}\T{/style:time12}';;
      ampm)        __ps1_prompt '{style:ampm}\@{/style:ampm}';;
      module:*)    echo -n '`__ps1_module '${tag:8}'`';;
      modules)     echo -n '`__ps1_modules`';;
      modules:eol) echo -n '`__ps1_modules -n`';;
      modules:pad) echo -n '`__ps1_modules -p`';;
      *)           echo -n "{$tag}";;
    esac
  done
}

__ps1_debug_output() {
  __ps1_debug "$1: "$(echo "$2" | perl -p -e 's/([^A-Za-z0-9!@#\$%\^\&\*\(\)_\+=\{\}\[\]:";'\''\<\>,\.~\`\/?-])//gsm') >2&
  echo -n "$2"
}

__ps1_module() {
  local exit="$?"
  module="$1"
  __ps1_debug "module: $module"
  local out="$(__ps1_module_${module} 2>/dev/null)"
  __ps1_debug "   out: $out"
  [[ "$out" ]] || return $exit
  __ps1_ansi_style $module
  __ps1_ansi_style module
  echo -n "$out"
  __ps1_ansi_style module_end
  __ps1_ansi_style ${module}_end
  return $exit
}

__ps1_modules() {
  PS1_LAST_ERR="$?"
  local newline=0; if [[ "$1" == '-n' ]]; then newline=1; shift; fi
  local pad=0;     if [[ "$1" == '-p' ]]; then pad=1;     shift; fi
  local enabled_modules=0
  for module in "${PS1_MODULES[@]}"; do
    module_out="$(__ps1_module $module)"
    [[ "$module_out" ]] || continue
    (( enabled_modules++ )) && __ps1_ansi_style 'module_pad'
    echo -n "$module_out"
    __ps1_ansi '{reset}'
  done
  if [[ "$enabled_modules" > 0 ]]; then
    if   [[ "$newline" == 1 ]]; then __ps1_ansi '{eol}'
    elif [[ "$pad"     == 1 ]]; then __ps1_ansi_style 'module_pad'; fi
  fi
  local err="$PS1_LAST_ERR"
  unset PS1_LAST_ERR
  return $err
}

for var in $(typeset | grep -v ORIG | grep -E ^PS1_.*= | cut -d '=' -f 1); do
  unset $var
done

# Process --key=val args into --key val, un-bundle single-letter flags,
# and treat -- as the end of explicit options
ar=(); for (( i=1; i<=$#; i++ )); do a="${@:$i:1}"
  [[   "$a" == '--'       ]] && ar+=("${@:$i}")            && break
  [[   "$a" == '--'*'='*  ]] && ar+=("${a%%=*}" "${a#*=}") && continue
  [[ ! "$a" =~ ^-([^-]+)$ ]] && ar+=("$a")                 && continue
  for (( x=1; x<${#a}; x++ )); do ar+=("-${a:$x:1}"); done
done; set -- "${ar[@]}"; unset a; unset ar

PS1_STYLES=('user' 'default')
#PS1_ROOT="$(cd "$(dirname ${BASH_SOURCE[0]})" &>/dev/null && pwd)"
#PS1_NAME="$(basename "${BASH_SOURCE[0]}")"
PS1_ROOT="$(cd `dirname ${BASH_SOURCE[0]}` &>/dev/null; echo $PWD)"
PS1_NAME="${BASH_SOURCE[0]##*/}"
PS1_SCRIPT="$PS1_ROOT/$PS1_NAME"
user_styles=()
load_modules=()
while (( "$#" > 0 )); do
  arg="$1"
  shift
  case "$arg" in
    -m|--module)       load_modules+=("$1"); shift ;;
    -a|--all-modules)  all_modules=1 ;;
    -b|--bold)         PS1_BOLD=1 ;;
    -s|--style)        PS1_STYLES=("$1" "${PS1_STYLES[@]}"); shift ;;
    -u|--user-style)   user_styles+=("$1"); shift ;;
    -p|--prompt)       set_prompt="$1"; shift ;;
    -d|--debug)        PS1_DEBUG=1 ;;
    -f|--title-format) PS1_TITLE_FORMAT="$1"; shift ;;
    -t|--title-mode)   PS1_TITLE_MODE="$1"; shift ;;
    -h|--help)         show_help=1 ;;
  esac
done


if [[ "$show_help" ]]; then
  for p in $PAGER less more cat; do
    which $p &>/dev/null && pager="$p" && break
  done
  cat <<EOF | $pager
USAGE: source $PS1_NAME [options]

Sets the prompt in a bash session

Options:

         --module NAME :  Enable module NAME
               -m NAME    Modules can be found in:
                            $PS1_ROOT/module

         --all-modules :  Enable all modules
                    -a

          --style NAME :  Enable style NAME
               -s NAME    Styles can be found in:
                            $PS1_ROOT/style

                --bold :  Bold all styles
                    -b    

                --help :  Shows help
                    -h

               --debug :  Enable debugging information
                    -d

 --title-format FORMAT :  Format for status line / window title using bash
             -f FORMAT    PS1 syntax
 
     --title-mode MODE :  Sets how status line / window title is handled
               -t MODE    Custom titles can be set with the 'title' command

                          MODE is one of:
                            prepend      Add custom-set title as the
                                         begining (default)

                            append       Add custom-set title at the end

                            static       No custom-set title

                            interpolate  Interpolate escape \\z in
                                         title-format as custom set title

                            disabled     No title set in prompt

For more information and additonal usage: https://github.com/kilna/prompt

EOF
  unset pager show_help
  [[ "${BASH_SOURCE[0]}" == "$0" ]] && exit 0 || return 0
fi
unset show_help


if [[ "${BASH_SOURCE[0]}" == "$0" ]]; then
  cat <<EOF >&2
This script is meant to be added into a Bash shell session via:

source $PS1_NAME

After loading, you can use 'prompt' to reload.
EOF
  exit 1
fi

__ps1_debug "PS1_ROOT: $PS1_ROOT"
__ps1_debug "PS1_SCRIPT: $PS1_SCRIPT"

if [[ "$all_modules" ]]; then
  load_modules=()
  for module_path in $PS1_ROOT/module/*; do
    load_modules+=("${module_path##*/}")
  done
fi
unset all_modules

for func in $(typeset -F | grep -v debug | cut -d ' ' -f 3 | grep -E '^__ps1_(style|module)_'); do
  __ps1_debug "Unsetting $func"
  unset -f $func
done

for user_style in "${user_styles[@]}"; do
  str="__ps1_style_user_${user_style%%=*}() { echo -n ${user_style#*=}; }"
  __ps1_debug "$str"
  eval "$str"
done
unset user_styles

err=0

PS1_MODULES=()
for module in "${load_modules[@]}"; do
  __ps1_debug "Loading module: $module"
  if ! source "${PS1_ROOT}/module/${module}"; then
    echo "Unable to open $PS1_NAME module $PS1_ROOT/modules/$module" >&2
    (( err++ ))
  fi
  if [[ "$(typeset -F __ps1_module_$module)" ]]; then
    __ps1_debug "Module $module successfully"
    PS1_MODULES+=("$module")
  fi
done

for style in "${PS1_STYLES[@]}"; do
  [[ "$style" == 'user' ]] && continue
  __ps1_debug "PS1_STYLE: $style"
  if ! source "${PS1_ROOT}/style/${style}"; then
    echo "Unable to open $PS1_NAME style $PS1_ROOT/style/$style" >&2
    (( err++ ))
  fi
done

PS1_TITLE_MODE="${PS1_TITLE_MODE:-prepend}"
__ps1_debug "PS1_TITLE_MODE: $PS1_TITLE_MODE"

PS1_TITLE_FORMAT="${PS1_TITLE_FORMAT:-\\u@\\h \\w}"
__ps1_debug "PS1_TITLE_FORMAT: $PS1_TITLE_FORMAT"


if [[ "${#set_prompt[@]}" -eq 0 ]]; then
  set_prompt='{modules:eol}{user}{reset}@{host} {dir}{eol}{prompt} {reset}'
fi

if [[ "$PS1_ORIG" == '' ]]; then PS1_ORIG="$PS1"; fi
__ps1_debug "PS1_ORIG: $PS1_ORIG"
__ps1_debug "Set prompt: $set_prompt"

export PS1="$(__ps1_prompt_title)$(__ps1_prompt "${set_prompt}")"
(( err+="$?" ))
__ps1_debug "PS1: $PS1"
unset set_prompt

for func in $(typeset -F | grep -v debug | cut -d ' ' -f 3 | grep -E '^__ps1_prompt_'); do
  __ps1_debug "Unsetting $func"
  unset -f $func
done

return $err

