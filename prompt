#!/bin/bash

if [ ! "$BASH" ]; then
  echo "Script is only compatible with bash, current shell is $SHELL" >&2
  exit 1
fi

title() {
  export PS1_TITLE="$1"
}

notitle() {
  unset PS1_TITLE
}

prompt() {
  export PS1="$PS1_ORIG"
  __ps1_debug "Running $PS1_SCRIPT"
  if [[ -e $PS1_SCRIPT ]]; then
    source $PS1_SCRIPT "$@"
  else
    echo "Unable to find PS1_SCRIPT: $PS1_SCRIPT" >&2
    return 1
  fi
}

noprompt() {
  export PS1="$PS1_ORIG"
  local debug="$PS1_DEBUG"
  __ps1_vars
  for var in "${PS1_VARS[@]}"; do
    if [[ "$var" != 'PS1_VARS' ]]; then
      [[ "$debug" ]] && echo "Unsetting $var" >&2
      unset $var &>/dev/null
    fi
  done
  unset PS1_VARS
  __ps1_funcs
  for func in "${PS1_FUNCS[@]}" title notitle prompt noprompt; do
    [[ "$debug" ]] && echo "Unsetting $func" >&2
    unset -f $func &>/dev/null
  done
  unset PS1_FUNCS
}

__ps1_lookup() {
  if typset -F __ps1_$1; then
    __ps1_$1
    return $?
  fi
  if typset -F ps1_$1; then
    ps1_$1
    return $?
  fi
  if typeset $1; then
    eval 'echo -n $ps1_'"$1"
    return 0
  fi
  return 1
}

__ps1_funcs() {
  export PS1_FUNCS=()
  while read line; do
    local f=($line)
    [[ "${f[2]}" == '__ps1_'* ]] && PS1_FUNCS+=("${f[2]}")
  done < <(typeset -F)
}

__ps1_vars() {
  export PS1_VARS=()
  while read line; do
    local f=($line)
    if [[ "${f[0]}" == 'declare' ]]; then
      var="${f[2]%%=*}"
      [[ "$var" == 'PS1_'* ]] && PS1_VARS+=("$var")
    fi
  done < <(typeset -p)
}

__ps1_debug() {
  [[ "$PS1_DEBUG" ]] && echo "$@" >&2
}

__ps1_unicode() {
  case "$LANG" in
    *'UTF-8'*) return 0;;
    *)         return 1;;
  esac
}

__ps1_load_style() {
  local file="$1"
  local is_unicode=0
  local code=''
  while read line; do
    [[ "$line" == '#'* || "$line" =~ ^[[:space:]]*$ ]] && continue
    if [[ "$line" != *':'* ]]; then
      echo "Unable to parse line '$line' in file '$file'" >&2
      continue
    else
      name="${line%%=*}"
      name="${name## }"
      name="${name%% }"
      val="${line#*=}"
      val="${val## }"
      val="${val%% }"
      [[ "$val" == *'{u:'* ]] && is_unicode=1
      code+="export PS1_SYLE_${name^^}='${val//\'/\\\'}'"$'\n';
    fi
  done < "$1"
  if [[ ! __ps1_unicode && is_unicode ]]; then
    echo "File '$file' contains unicode style information but terminal is not UTF-8" >&2
  fi
  eval "$code"
}

__ps1_parse_tags() {
  ar=()
  for str in "$@"; do
    while [[ "$str" != '' ]]; do
      x="${str%%\{*}"
      [[ "$x" = "$str" ]] || (( idx1 = ${#x} + 1 ))
      x="${str%%\}*}"
      [[ "$x" = "$str" ]] || (( idx2 = ${#x} + 1 ))
      nontag_val=''
      tag_val=''
      if [[ "$idx1" != '' && "$idx2" != '' && (( idx2 > idx1 )) ]]; then
        substr="${str:0:(( idx2 ))}"
        x="${substr%\{*}"
        [[ "$x" = "$substr" ]] || (( idx1 = ${#x} + 1 ))
        if [[ "$idx1" == '' ]]; then
          nontag_val+="$substr"
        else
          if (( idx1 != 0 )); then
            nontag_val+="${str:0:(( idx1 - 1 ))}"
          fi
          tag_val="${str:(( idx1 - 1 )):(( idx2 - idx1 + 1 ))}"
        fi
        str="${str:$idx2}"
      else
        nontag_val+="$str"
        str=''
      fi
      ar_idx=$(( "${#ar[@]}" - 1 ))
      if [[ "$nontag_val" != '' ]]; then
        if [[ "$ar_idx" -lt 0 || "${ar[$ar_idx]}" == '{'*'}' ]]; then
          ar+=("$nontag_val")
        else
          ar[$ar_idx]+="$nontag_val" 
        fi
      fi
      if [[ "$tag_val" != '' ]]; then
        ar+=("$tag_val")
      fi
    done
  done
  export ps1_tags_parsed=("${ar[@]}")
}

__ps1_ansi_echo() {
  [[ -z "$PS1_COLORS" || "$PS1_COLORS" == '0' ]] || echo -en "$1"
}

__ps1_ansi_style() {
  [[ "$PS1_BOLD" ]] && __ps1_ansi '{bold}'
  for property in "$1" 'default'; do
    for style in "${PS1_STYLES[@]}"; do
      local out
      IFS='' read -r out < <(__ps1_style_${style}_${property} 2>/dev/null)
      if [[ "$out" != '' ]]; then
        __ps1_ansi "$out"
        return
      fi
    done
  done
}

__ps1_rgb() {
  # Rounds to the nearest ANSI 216 color cube or 24 grayscale value. See:
  # https://docs.google.com/spreadsheets/d/1n4zg5OXYC0hBdRKBb1clx4t2HSx_cu_iiot6GYpgh1c/
  local r="$1"
  local g="$2"
  local b="$3"

  if [[ "$PS1_COLORS" == '24bit' ]]; then
    echo -n "2;${r};${g};${b}m"
    return
  fi

  local min=''
  local max=''
  local total=0
  for c in $r $g $b; do
    if [[ "$min" == '' ]] || (( $c < $min )); then min="$c"; fi
    if [[ "$max" == '' ]] || (( $c > $max )); then max="$c"; fi
    total=$(( total + $c ))
  done

  local idx=''
  if (( ( max - min ) <= 26 )); then
    # If the delta between min and max is less than 26 (roughly 1/2 the 51.2
    # shades per 6x6x6 colors) then the color is effectively gray.
    local gray=$(( total / 3 )) # RGB colors as passed averaged into single 0-255 gray
    if ! ((
      (                gray < 8   ) ||
      ( gray >= 51  && gray < 58  ) ||
      ( gray >= 102 && gray < 108 ) ||
      ( gray >= 153 && gray < 158 ) ||
      ( gray >= 204 && gray < 208 ) ||
      ( gray >= 248               )
    )); then
      # If we aren't better matched to the 6x6x6 cube, use a 24-shade ANSI gray
      idx=$(( 230 + ( ( $gray + 12 ) / 10 ) ))
    fi
  fi

  if [[ "$idx" == '' ]]; then
    # Otherwise, map to ANSI 216 indexed color cube
    idx=$((
      16                            +
      ( ( ( $r + 26 ) / 51 ) * 36 ) +
      ( ( ( $g + 26 ) / 51 ) * 6  ) +
      ( ( ( $b + 26 ) / 51 ) * 1  )
    ))
  fi

  echo -n "5;${idx}m"
}

PS1_EXTGLOB=$(shopt -p extglob)
shopt -s extglob
__ps1_color() {
  # If we're foreground $g is set to 3, if background it's set to 4
  local g='3'; if [[ "${1:0:2}" == 'bg' ]]; then g='4'; fi
  local spec="${1:3}"
  __ps1_debug "COLOR TAG: $1 FG/BG: $g SPEC: $spec"
  #local out=$(
    case "$spec" in
      black)    echo -n "${g}0m";;
      red)      echo -n "${g}1m";;
      green)    echo -n "${g}2m";;
      yellow)   echo -n "${g}3m";;
      blue)     echo -n "${g}4m";;
      magenta)  echo -n "${g}5m";;
      cyan)     echo -n "${g}6m";;
      white)    echo -n "${g}7m";;
      +([0-9])) echo -n "${g}8;5;${spec}m";;
      +([0-9]),+([0-9]),+([0-9]))
                echo -n "${g}8;"
                __ps1_rgb ${spec//,/ };;
      \#[0-9A-Fa-f][0-9A-Fa-f][0-9A-Fa-f][0-9A-Fa-f][0-9A-Fa-f][0-9A-Fa-f])
                echo -n "${g}8;"
                __ps1_rgb $(( 16#${spec:1:2} )) $(( 16#${spec:3:2} )) $(( 16#${spec:5:2} ))
                ;;
      \#[0-9A-Fa-f][0-9A-Fa-f][0-9A-Fa-f])
                echo -n "${g}8;"
                __ps1_rgb \
                  "$(( ( 16#${spec:1:1} * 16 ) + 16#${spec:1:1} ))" \
                  "$(( ( 16#${spec:2:1} * 16 ) + 16#${spec:2:1} ))" \
                  "$(( ( 16#${spec:3:1} * 16 ) + 16#${spec:3:1} ))"
                ;;
      *)        echo -n 'm';;
    esac
  #)
  #__ps1_debug "COLOR OUT: $out"
  #echo -n "$out"
}
eval "$PS1_EXTGLOB"
unset PS1_EXTGLOB

__ps1_ansi() {
  export ps1_tags_parsed=()
  __ps1_parse_tags "$@"
  set -- "${ps1_tags_parsed[@]}"
  for x in "$@"; do
    __ps1_debug "CHUNK: '$x'"
  done
  unset ps1_tags_parsed
  trap "$(shopt -p extglob)" RETURN
  shopt -s extglob
  while (( "$#" > 0 )); do
    arg="$1"
    shift
    [[ "$arg" != '{'*'}' ]] && echo -n "$arg" && continue
    tag="${arg:1:$(( ${#arg} - 2 ))}"
    case "$tag" in
      style:*)    __ps1_ansi_style "${tag:6}";;
      /style:*)   __ps1_ansi_style "${tag:7}_end";;
      eol)        __ps1_ansi_echo '\n\e[0m';; # Handy when bash eats a trailing newline
      clear)      __ps1_ansi_echo '\e[H\e[2J';;
      reset)      __ps1_ansi_echo '\e[0m';;
      fg:*|bg:*)  __ps1_ansi_echo '\e['"$(__ps1_color $tag)";;
      bold)       __ps1_ansi_echo '\e[1m';;
      dim)        __ps1_ansi_echo '\e[2m';;
      italic)     __ps1_ansi_echo '\e[3m';;
      underline)  __ps1_ansi_echo '\e[4m';;
      blink)      __ps1_ansi_echo '\e[5m';;
      fastblink)  __ps1_ansi_echo '\e[6m';;
      reverse)    __ps1_ansi_echo '\e[7m';;
      hidden)     __ps1_ansi_echo '\e[8m';;
      /bold)      __ps1_ansi_echo '\e[21m';;
      /dim)       __ps1_ansi_echo '\e[22m';;
      /italic)    __ps1_ansi_echo '\e[23m';;
      /underline) __ps1_ansi_echo '\e[24m';;
      /blink)     __ps1_ansi_echo '\e[25m';;
      /fastblink) __ps1_ansi_echo '\e[26m';;
      /reverse)   __ps1_ansi_echo '\e[27m';;
      /hidden)    __ps1_ansi_echo '\e[28m';;
      space)      echo -n ' ';;
      *)          echo -n "{$tag}";;
    esac
  done
}

__ps1_title() {
  local last_err="$?" # Cache last command's error...
  if [[ "$PS1_TITLE" ]]; then
    case "$PS1_TITLE_MODE" in
      prepend)     echo -n "$PS1_TITLE"' - ';;
      append)      echo -n ' - '"$PS1_TITLE";;
      interpolate) echo -n "$PS1_TITLE";;
    esac
  fi
  return $last_err # Needed by __ps1_modules to show error
}

__ps1_prompt_title() {
  if [[ "$PS1_TITLE_MODE" != 'disabled' ]]; then
    echo -n '\[\e]0;\]'
    case "$PS1_TITLE_MODE" in
      static)      echo -n "$PS1_TITLE_FORMAT";;
      prepend)     echo -n '`__ps1_title`'"$PS1_TITLE_FORMAT";;
      append)      echo -n "$PS1_TITLE_FORMAT"'`__ps1_title`';;
      interpolate) echo -n "${PS1_TITLE_FORMAT//\\z/'`__ps1_title`'}";;
    esac
    echo -n '\a'
  fi
}

__ps1_prompt_style() {
  [[ "$PS1_BOLD" ]] && __ps1_prompt '{bold}'
  for property in "$1" 'default'; do
    for style in "${PS1_STYLES[@]}"; do
      local out
      IFS='' read -r out < <(__ps1_style_${style}_${property} 2>/dev/null)
      if [[ "$out" != '' ]]; then
        __ps1_prompt "$out"
        return
      fi
    done
  done
}

__ps1_prompt() {
  export ps1_tags_parsed=()
  __ps1_parse_tags "$@"
  set -- "${ps1_tags_parsed[@]}"
  unset ps1_tags_parsed
  trap "$(shopt -p extglob)" RETURN
  shopt -s extglob
  while (( "$#" > 0 )); do
    arg="$1"
    shift
    [[ "$arg" != '{'*'}' ]] && echo -n "$arg" && continue
    tag="${arg:1:$(( ${#arg} - 2 ))}"
    case "$tag" in
      style:*)     __ps1_prompt_style "${tag:6}";;
      /style:*)    __ps1_prompt_style "${tag:7}_end";;
      eol)         echo -n '\n\[\e[0m\]';; # Handy when bash eats a trailing newline
      clear)       echo -n '\[\e[H\e[2J\]';;
      reset)       echo -n '\[\e[0m\]';;
      fg:*|bg:*)   echo -n '\e['; __ps1_color "$tag"; echo -n '\]';;
      bold)        echo -n '\[\e[1m\]';;
      dim)         echo -n '\[\e[2m\]';;
      italic)      echo -n '\[\e[3m\]';;
      underline)   echo -n '\[\e[4m\]';;
      blink)       echo -n '\[\e[5m\]';;
      fastblink)   echo -n '\[\e[6m\]';;
      reverse)     echo -n '\[\e[7m\]';;
      hidden)      echo -n '\[\e[8m\]';;
      /bold)       echo -n '\[\e[21m\]';;
      /dim)        echo -n '\[\e[22m\]';;
      /italic)     echo -n '\[\e[23m\]';;
      /underline)  echo -n '\[\e[24m\]';;
      /blink)      echo -n '\[\e[25m\]';;
      /fastblink)  echo -n '\[\e[26m\]';;
      /reverse)    echo -n '\[\e[27m\]';;
      /hidden)     echo -n '\[\e[28m\]';;
      user)        __ps1_prompt '{style:user}\u{/style:user}';;
      dir)         __ps1_prompt '{style:dir}\w{/style:dir}';;
      basename)    __ps1_prompt '{style:basename}\W{/style:basename}';;
      host)        __ps1_prompt '{style:host}\h{/style:host}';;
      fqdn)        __ps1_prompt '{style:fqdn}\H{/style:fqdn}';;
      prompt)      __ps1_prompt '{style:prompt}\${/style:prompt}';;
      date)        __ps1_prompt '{style:date}\d{/style:date}';;
      time)        __ps1_prompt '{style:time}\t{/style:time}';;
      time12)      __ps1_prompt '{style:time12}\T{/style:time12}';;
      ampm)        __ps1_prompt '{style:ampm}\@{/style:ampm}';;
      module:*)    echo -n '`__ps1_module '${tag:8}'`';;
      modules)     echo -n '`__ps1_modules`';;
      modules:eol) echo -n '`__ps1_modules -n`';;
      modules:pad) echo -n '`__ps1_modules -p`';;
      *)           echo -n "{$tag}";;
    esac
  done
}

__ps1_module() {
  local exit="$?"
  module="$1"
  __ps1_debug "module: $module"
  #local out="$(__ps1_module_${module} 2>/dev/null)"
  local out
  IFS='' read -r out < <(__ps1_module_${module} 2>/dev/null)
  __ps1_debug "   out: $out"
  [[ "$out" ]] || return $exit
  __ps1_ansi_style $module
  __ps1_ansi_style module
  echo -n "$out"
  __ps1_ansi_style module_end
  __ps1_ansi_style ${module}_end
  return $exit
}

__ps1_modules() {
  PS1_LAST_ERR="$?"
  local newline=0
  if [[ "$1" == '-n' ]]; then
    newline=1
    shift
  fi
  local pad=0
  if [[ "$1" == '-p' ]]; then
    pad=1
    shift
  fi
  local enabled_modules=0
  for module in "${PS1_MODULES[@]}"; do
    # local module_out="$(__ps1_module $module)"
    local module_out
    IFS='' read -r module_out < <(__ps1_module $module)
    [[ "$module_out" ]] || continue
    (( enabled_modules++ )) && __ps1_ansi_style 'module_pad'
    echo -n "$module_out"
    __ps1_ansi '{reset}'
  done
  if [[ "$enabled_modules" > 0 ]]; then
    if [[ "$newline" == 1 ]]; then
      __ps1_ansi '{eol}'
    elif [[ "$pad"     == 1 ]]; then
      __ps1_ansi_style 'module_pad'
    fi
  fi
  local err="$PS1_LAST_ERR"
  unset PS1_LAST_ERR
  return $err
}

__ps1_vars
for var in "${PS1_VARS[@]}"; do
  [[ "$var" != 'PS1_ORIG' && "$var" != 'PS1_VARS' ]] && unset $var
done
unset PS1_VARS

# Process --key=val args into --key val, un-bundle single-letter flags,
# and treat -- as the end of explicit options
ar=()
for (( i=1; i<=$#; i++ )); do
  a="${@:$i:1}"
  [[   "$a" == '--'       ]] && ar+=("${@:$i}")            && break
  [[   "$a" == '--'*'='*  ]] && ar+=("${a%%=*}" "${a#*=}") && continue
  [[ ! "$a" =~ ^-([^-]+)$ ]] && ar+=("$a")                 && continue
  for (( x=1; x<${#a}; x++ )); do ar+=("-${a:$x:1}"); done
done
set -- "${ar[@]}"
unset a ar

PS1_STYLES=('user' 'default')
PS1_ROOT="$(cd `dirname ${BASH_SOURCE[0]}` &>/dev/null; echo $PWD)"
PS1_NAME="${BASH_SOURCE[0]##*/}"
PS1_SCRIPT="$PS1_ROOT/$PS1_NAME"
case "$TERM$COLORTERM" in
  *truecolor*|*24bit*)
      PS1_COLORS='24bit';;
  *256*)
      PS1_COLORS='256';;
  *)
      t="$(infocmp 2>/dev/null)"
      if [[ "$t" =~ ^.*[[:space:]](Tc|tc|RGB|rgb),[[:space:]].*$ ]]; then
        PS1_COLORS='24bit'
      elif [[ "$t" =~ ^.*[[:space:]]set(24f|f24|rgbf)=[^[:space:]]+,[[:space:]].*$ ]]; then
        PS1_COLORS='24bit'
      else
        for idx in 1 7 15 255; do
          read -p "$(printf '\e]4;%d;?\a' $idx)" -d $'\a' -s -t 0.1 response </dev/tty
          [[ -z "$response" ]] && break
          PS1_COLORS=$(( idx + 1 ))
        done
        unset response
      fi
      if [[ -z "$PS1_COLORS" && "$t" =~ ^.*[[:space:]]colors#([0-9]+),[[:space:]].*$ ]]; then
        PS1_COLORS="${BASH_REMATCH[1]}"
      fi
      unset t
      PS1_COLORS="${PS1_COLORS:-$(tput colors 2>/dev/null)}" # This shoudl work with termcap
      PS1_COLORS="${PS1_COLORS:-0}"
      ;;
esac

user_styles=()
load_modules=()
while (( "$#" > 0 )); do
  arg="$1"
  shift
  case "$arg" in
    -m|--module)       load_modules+=("$1"); shift ;;
    -a|--all-modules)  all_modules=1 ;;
    -b|--bold)         PS1_BOLD=1 ;;
    -s|--style)        PS1_STYLES=("$1" "${PS1_STYLES[@]}"); shift ;;
    -u|--user-style)   user_styles+=("$1"); shift ;;
    -p|--prompt)       set_prompt="$1"; shift ;;
    -d|--debug)        PS1_DEBUG=1 ;;
    -c|--colors)       PS1_COLORS=("$1"); shift;;
    -f|--title-format) PS1_TITLE_FORMAT="$1"; shift ;;
    -t|--title-mode)   PS1_TITLE_MODE="$1"; shift ;;
    -h|--help)         show_help=1 ;;
  esac
done

if [[ "$show_help" ]]; then
  for p in $PAGER less more cat; do
    which $p &>/dev/null && pager="$p" && break
  done
  cat <<EOF | $pager
USAGE: source $PS1_NAME [options]

Sets the prompt in a bash session

Options:

         --module NAME :  Enable module NAME
               -m NAME    Modules can be found in:
                            $PS1_ROOT/module

         --all-modules :  Enable all modules
                    -a

          --style NAME :  Enable style NAME
               -s NAME    Styles can be found in:
                            $PS1_ROOT/style

         --colors SPEC :  Override auto-detection for the number of ANSI colors
               -c SPEC      the current terminal supports.

                          SPEC is one of:
                            0       No ANSI color support
                            8
                            16
                            256
                            24bit   Truecolor ANSI terminal support

                --bold :  Bold all styles
                    -b    

                --help :  Shows help
                    -h

               --debug :  Enable debugging information
                    -d

 --title-format FORMAT :  Format for status line / window title using bash
             -f FORMAT    PS1 syntax
 
     --title-mode MODE :  Sets how status line / window title is handled
               -t MODE    Custom titles can be set with the 'title' command

                          MODE is one of:
                            prepend      Add custom-set title as the
                                         begining (default)

                            append       Add custom-set title at the end

                            static       No custom-set title

                            interpolate  Interpolate escape \\z in
                                         title-format as custom set title

                            disabled     No title set in prompt

For more information and additonal usage: https://github.com/kilna/prompt

EOF
  unset pager show_help
  [[ "${BASH_SOURCE[0]}" == "$0" ]] && exit 0 || return 0
fi
unset show_help


if [[ "${BASH_SOURCE[0]}" == "$0" ]]; then
  cat <<EOF >&2
This script is meant to be added into a Bash shell session via:

source $PS1_NAME

After loading, you can use 'prompt' to reload.
EOF
  exit 1
fi

__ps1_debug "PS1_ROOT: $PS1_ROOT"
__ps1_debug "PS1_NAME: $PS1_NAME"
__ps1_debug "PS1_SCRIPT: $PS1_SCRIPT"

if [[ "$all_modules" ]]; then
  load_modules=()
  for module_path in $PS1_ROOT/module/*; do
    load_modules+=("${module_path##*/}")
  done
fi
unset all_modules

__ps1_funcs
for func in "${PS1_FUNCS[@]}"; do
  if [[ "$func" == '__ps1_module_'* || "$func" == '__ps1_style_'* ]]; then
    __ps1_debug "Unsetting $func"
    unset -f $func
  fi
done
unset PS1_FUNCS

for user_style in "${user_styles[@]}"; do
  str="__ps1_style_user_${user_style%%=*}() { echo -n '${user_style#*=}'; }"
  __ps1_debug "$str"
  eval "$str"
done
unset user_styles

err=0

PS1_MODULES=()
for module in "${load_modules[@]}"; do
  __ps1_debug "Loading module: $module"
  if ! source "${PS1_ROOT}/module/${module}"; then
    echo "Unable to open $PS1_NAME module $PS1_ROOT/modules/$module" >&2
    (( err++ ))
  fi
  if typeset -F __ps1_module_$module &>/dev/null; then
    __ps1_debug "Module $module loaded successfully"
    PS1_MODULES+=("$module")
  fi
done


for style in "${PS1_STYLES[@]}"; do
  [[ "$style" == 'user' ]] && continue
  __ps1_debug "PS1_STYLE: $style"
  if ! source "${PS1_ROOT}/style/${style}"; then
    echo "Unable to open $PS1_NAME style $PS1_ROOT/style/$style" >&2
    (( err++ ))
  fi
done

PS1_TITLE_MODE="${PS1_TITLE_MODE:-prepend}"
__ps1_debug "PS1_TITLE_MODE: $PS1_TITLE_MODE"

PS1_TITLE_FORMAT="${PS1_TITLE_FORMAT:-\\u@\\h \\w}"
__ps1_debug "PS1_TITLE_FORMAT: $PS1_TITLE_FORMAT"


if [[ "${#set_prompt[@]}" -eq 0 ]]; then
  set_prompt='{modules:eol}{user}{reset}@{host} {dir}{eol}{prompt} {reset}'
fi

if [[ "$PS1_ORIG" == '' ]]; then PS1_ORIG="$PS1"; fi
__ps1_debug "PS1_ORIG: $PS1_ORIG"
__ps1_debug "Set prompt: $set_prompt"

IFS='' read -r -d $'\0' title < <(__ps1_prompt_title)
IFS='' read -r -d $'\0' prompt < <(__ps1_prompt "$set_prompt")
export PS1="$title$prompt"
(( err+="$?" ))
__ps1_debug "PS1: $PS1"
unset set_prompt

__ps1_funcs
for func in "${PS1_FUNCS[@]}"; do
  if [[ "$func" == '__ps1_prompt_'* ]]; then
    [[ "$debug" ]] && echo "Unsetting $func" >&2
    unset -f $func &>/dev/null
  fi
done
unset PS1_FUNCS

return $err

